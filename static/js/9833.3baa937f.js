"use strict";(self.webpackChunkICDC_Frontend=self.webpackChunkICDC_Frontend||[]).push([[9833],{89833:(t,e,n)=>{n.r(e),n.d(e,{default:()=>v});var o=n(2340),s=n(88482),a=n(34105),r=n(9084),i=n(48825),c=n(30880),d=n(88476),l=n(7562);function u(t){return f(t.type)?1:t.length}function f(t){return"softclip"===t||"hardclip"===t||"insertion"===t}function p(t,e,n,o){let s=t[n][o];void 0===s&&(s=t[n][o]={total:0,"-1":0,0:0,1:0}),s.total++,s[e]++}class v extends o.BaseFeatureDataAdapter{async configure(){var t,e;const n=this.getConf("subadapter"),o=n.sequenceAdapter,s=await(null===(t=this.getSubAdapter)||void 0===t?void 0:t.call(this,n)),a=o?await(null===(e=this.getSubAdapter)||void 0===e?void 0:e.call(this,o)):void 0;if(!s)throw new Error("Failed to get subadapter");return{subadapter:s.dataAdapter,sequenceAdapter:null==a?void 0:a.dataAdapter}}async fetchSequence(t){const{sequenceAdapter:e}=await this.configure();if(e)return(0,c.Iw)(t,e)}getFeatures(t,e={}){return(0,a.ObservableCreate)((async n=>{const{subadapter:o}=await this.configure(),a=await(0,i._)(o.getFeatures(t,e).pipe((0,r.$)())),{bins:v,skipmap:h}=await async function(t,e,n,o){var s,a,r;const{colorBy:i}=n,v={...e,start:Math.max(0,e.start-1),end:e.end+1},h=Math.ceil(v.end-v.start),g={},m=t.length&&(0,c.k_)(null===(s=n.colorBy)||void 0===s?void 0:s.type)?await o(e):void 0,w=[];for(const n of t){const t=n.get("start"),o=n.get("end"),s=n.get("strand"),v=n.get("mismatches")||[];for(let n=t;n<o+1;n++){const t=n-e.start;t>=0&&t<h&&(void 0===w[t]&&(w[t]={total:0,all:0,ref:0,"-1":0,0:0,1:0,lowqual:{},cov:{},delskips:{},noncov:{}}),n!==o&&(w[t].total++,w[t].all++,w[t].ref++,w[t][s]++))}if("modifications"===(null==i?void 0:i.type)){const o=n.get("seq"),a=(0,c.c$)(n,"MM","Mm")||"",r=(0,d.eL)(n.get("CIGAR")),i=n.get("end");if(o){const n=(0,d.xA)(a,o,s);for(const{type:o,positions:a}of n){const n=`mod_${o}`;for(const o of(0,d.hn)(r,a)){const a=o+t-e.start;if(a>=0&&a<w.length&&o+t<i){void 0===w[a]&&(w[a]={total:0,all:0,ref:0,"-1":0,0:0,1:0,lowqual:{},cov:{},delskips:{},noncov:{}});const t=w[a];t?p(t,s,"cov",n):console.warn("Undefined position in modifications snpcoverage encountered")}}}}}if("methylation"===(null==i?void 0:i.type)){if(!m)throw new Error("no region sequence detected, need sequenceAdapter configuration");if(!n.get("seq"))continue;const{methBins:i,methProbs:c}=(0,d.Ps)(n),u=v.filter((t=>"deletion"===t.type));for(let n=0;n<o-t;n++){const o=n+t,d=null===(a=m[o-e.start+1])||void 0===a?void 0:a.toLowerCase(),f=null===(r=m[o-e.start+2])||void 0===r?void 0:r.toLowerCase();if("c"===d&&"g"===f){const a=w[o-e.start],r=w[o-e.start+1],d=i[n],f=i[n+1],v=c[n],h=c[n+1];d&&(void 0===v||v>.5)||f&&(void 0===h||h>.5)?(a&&(p(a,s,"cov","meth"),a.ref--,a[s]--),r&&(p(r,s,"cov","meth"),r.ref--,r[s]--)):(a&&((null==u?void 0:u.some((e=>(0,l.doesIntersect2)(o,o+1,e.start+t,e.start+t+e.length))))||(p(a,s,"cov","unmeth"),a.ref--,a[s])),r&&((null==u?void 0:u.some((e=>(0,l.doesIntersect2)(o+1,o+2,e.start+t,e.start+t+e.length))))||(p(r,s,"cov","unmeth"),r.ref--,r[s]--)))}}}const y="modifications"!==(null==i?void 0:i.type)&&"methylation"!==(null==i?void 0:i.type);for(const o of v){const a=t+o.start,r=u(o),i=a+r;for(let t=a;t<a+r;t++){const n=t-e.start;if(n>=0&&n<w.length){const t=w[n],{base:e,type:a}=o,r=f(a);r?p(t,s,"noncov",a):(t.ref--,t[s]--),"deletion"===a||"skip"===a?(p(t,s,"delskips",a),t.total--):!r&&y&&(p(t,s,"cov",e),t.refbase=o.altbase)}}if("skip"===o.type){const t=`${a}_${i}_${s}`;void 0===g[t]&&(g[t]={feature:n,start:a,end:i,strand:s,xs:(0,c.bH)(n,"XS")||(0,c.bH)(n,"TS"),score:0}),g[t].score++}}}return{bins:w,skipmap:g}}(a,t,e,(t=>this.fetchSequence(t)));v.forEach(((e,o)=>{const a=t.start+o;n.next(new s.default({id:`${this.id}-${a}`,data:{score:e.total,snpinfo:e,start:a,end:a+1,refName:t.refName}}))})),Object.entries(h).forEach((([t,e])=>{n.next(new s.default({id:t,data:{type:"skip",start:e.start,end:e.end,strand:e.strand,score:e.score,xs:e.xs}}))})),n.complete()}),e.signal)}async getMultiRegionFeatureDensityStats(t,e){const{subadapter:n}=await this.configure();return n.getMultiRegionFeatureDensityStats(t,e)}async getRefNames(t={}){const{subadapter:e}=await this.configure();return e.getRefNames(t)}freeResources(){}}}}]);