/*! For license information please see 1537.5ebe1bb6.js.LICENSE.txt */
(self.webpackChunkICDC_Frontend=self.webpackChunkICDC_Frontend||[]).push([[1537],{91537:(A,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>KA});const r=1,i=2,n=4,s=8,o=1,a=2,g=4,I=8,C=16,c=32,d=64,h=128,Q=256,l=512,B=1024,f=2048,u={a:0,A:0,c:1,C:1,g:2,G:2,t:3,T:3,n:4,N:4};function E(A){const e={};for(const[t,r]of A)e["is"+r]=A=>!!(A&t),e["set"+r]=A=>A|t;return e}const m=E([[1,"Paired"],[2,"ProperlyPaired"],[4,"SegmentUnmapped"],[8,"MateUnmapped"],[16,"ReverseComplemented"],[32,"MateReverseComplemented"],[64,"Read1"],[128,"Read2"],[256,"Secondary"],[512,"FailedQc"],[1024,"Duplicate"],[2048,"Supplementary"]]),p=E([[1,"PreservingQualityScores"],[2,"Detached"],[4,"WithMateDownstream"],[8,"DecodeSequenceAsStar"]]),w=E([[1,"OnNegativeStrand"],[2,"Unmapped"]]);class S{constructor({flags:A,cramFlags:e,readLength:t,mappingQuality:r,lengthOnRef:i,qualityScores:n,mateRecordNumber:s,readBases:o,readFeatures:a,mateToUse:g,readGroupId:I,readName:C,sequenceId:c,uniqueId:d,templateSize:h,alignmentStart:Q,tags:l}){this.flags=A,this.cramFlags=e,this.readLength=t,this.mappingQuality=r,this.lengthOnRef=i,this.qualityScores=n,o&&(this.readBases=o),this.readGroupId=I,this.readName=C,this.sequenceId=c,this.uniqueId=d,this.templateSize=h,this.alignmentStart=Q,this.tags=l,a&&(this.readFeatures=a),g&&(this.mate={flags:g.mateFlags,readName:g.mateReadName,sequenceId:g.mateSequenceId,alignmentStart:g.mateAlignmentStart}),s&&(this.mateRecordNumber=s)}isPaired(){return!!(this.flags&o)}isProperlyPaired(){return!!(this.flags&a)}isSegmentUnmapped(){return!!(this.flags&g)}isMateUnmapped(){return!!(this.flags&I)}isReverseComplemented(){return!!(this.flags&C)}isMateReverseComplemented(){return!!(this.flags&c)}isRead1(){return!!(this.flags&d)}isRead2(){return!!(this.flags&h)}isSecondary(){return!!(this.flags&Q)}isFailedQc(){return!!(this.flags&l)}isDuplicate(){return!!(this.flags&B)}isSupplementary(){return!!(this.flags&f)}isDetached(){return!!(this.cramFlags&i)}hasMateDownStream(){return!!(this.cramFlags&n)}isPreservingQualityScores(){return!!(this.cramFlags&r)}isUnknownBases(){return!!(this.cramFlags&s)}getReadBases(){if(!this.readBases&&this._refRegion){const A=function(A,e){if(!A.lengthOnRef&&!A.readLength)return null;if(A.isUnknownBases())return null;const t=A.alignmentStart-e.start;if(!A.readFeatures)return e.seq.slice(t,t+(A.lengthOnRef||0)).toUpperCase();let r="",i=t,n=0;for(;r.length<A.readLength;)if(n<A.readFeatures.length){const t=A.readFeatures[n];if("Q"===t.code||"q"===t.code)n+=1;else if(t.pos===r.length+1)if(n+=1,"b"===t.code){const A=t.data;r+=A,i+=A.length}else"B"===t.code?(r+=t.data[0],i+=1):"X"===t.code?(r+=t.sub,i+=1):"I"===t.code?r+=t.data:"D"===t.code?i+=t.data:"i"===t.code?r+=t.data:"N"===t.code?i+=t.data:"S"===t.code?r+=t.data:"P"===t.code||t.code;else if(n<A.readFeatures.length){const t=e.seq.slice(i,i+A.readFeatures[n].pos-r.length-1);r+=t,i+=t.length}}else{const t=e.seq.slice(i,i+A.readLength-r.length);r+=t,i+=t.length}return r.toUpperCase()}(this,this._refRegion);A&&(this.readBases=A)}return this.readBases}getPairOrientation(){if(!this.isSegmentUnmapped()&&this.isPaired()&&!this.isMateUnmapped()&&this.mate&&this.sequenceId===this.mate.sequenceId){const A=this.isReverseComplemented()?"R":"F",e=this.isMateReverseComplemented()?"R":"F";let t=" ",r=" ";this.isRead1()?(t="1",r="2"):this.isRead2()&&(t="2",r="1");const i=[];let n=this.templateLength||this.templateSize;if(void 0===n)throw new Error("One of templateSize and templateLength must be set");return this.alignmentStart>this.mate.alignmentStart&&n>0&&(n=-n),n>0?(i[0]=A,i[1]=t,i[2]=e,i[3]=r):(i[2]=A,i[3]=t,i[0]=e,i[1]=r),i.join("")}return null}addReferenceSequence(A,e){this.readFeatures&&this.readFeatures.forEach((t=>{"X"===t.code&&function(A,e,t,r){if(!e)return;const i=r.refPos-e.start,n=e.seq.charAt(i);n&&(r.ref=n);let s=u[n];void 0===s&&(s=4);const o=t.substitutionMatrix[s][r.data];o&&(r.sub=o)}(0,A,e,t)})),!this.readBases&&A.start<=this.alignmentStart&&A.end>=this.alignmentStart+(this.lengthOnRef||this.readLength)-1&&(this._refRegion=A)}toJSON(){const A={};return Object.keys(this).forEach((e=>{e.startsWith("_")||(A[e]=this[e])})),A.readBases=this.getReadBases(),A}}var y=t(51668);function D(A){return Buffer.from((0,y.inflate)(A))}var N=t(76548),k=t(87392),b=t.n(k),q=t(46960),F=t.n(q),L=t(70235),R=t.n(L),H=t(41307);class _ extends Error{}class J extends Error{}class G extends _{}class M extends _{}class v extends _{}const P=12,Y=4096,x=1<<23;class K{constructor(){this.F=void 0,this.C=void 0}}function U(A,e,t,r){return t*(A>>r)+(A&(1<<r)-1)-e}const z={FC:K,AriDecoder:class{constructor(){this.fc=new Array(256);for(let A=0;A<this.fc.length;A+=1)this.fc[A]=new K;this.R=null}},Symbol:class{constructor(){this.start=void 0,this.freq=void 0}},symbolInit:function(A,e,t){if(!(e<=65536))throw new G("assertion failed: start <= 1<<16");if(!(t<=65536-e))throw new G("assertion failed: freq <= 1<<16");A.start=e,A.freq=t},advanceStep:U,advanceSymbolStep:function(A,e,t){return U(A,e.start,e.freq,t)},get:function(A,e){return A&(1<<e)-1},advanceSymbol:function(A,e,t,r){return function(A,e,t,r,i){if((A=r*(A>>i)+(A&(1<<i)-1)-t)<x)do{A=A<<8|255&e.get()}while(A<x);return A}(A,e,t.start,t.freq,r)},renormalize:function(A,e){if(A<x)do{A=A<<8|255&e.get()}while(A<x);return A}};function T(A){if(!A)throw new G("assertion failed")}class O{constructor(A,e=0){this._buffer=A,this._position=e,this.length=A.length}get(){const A=this._buffer[this._position];return this._position+=1,A}getByte(){return this.get()}getByteAt(A){return this._buffer[A]}position(){return this._position}put(A){return this._buffer[this._position]=A,this._position+=1,A}putAt(A,e){return this._buffer[A]=e,e}setPosition(A){return this._position=A,A}getInt(){const A=this._buffer.readInt32LE(this._position);return this._position+=4,A}remaining(){return this._buffer.length-this._position}}var $=t(57936);const X=(new $.i).itf8(),W={parser:(new $.i).string("magic",{length:4}).uint8("majorVersion").uint8("minorVersion").string("fileId",{length:20,stripNull:!0}),maxLength:26},j={parser:(new $.i).uint8("compressionMethod",{formatter:A=>{const e=["raw","gzip","bzip2","lzma","rans","rans4x16","arith","fqzcomp","tok3"][A];if(!e)throw new Error(`compression method number ${A} not implemented`);return e}}).uint8("contentType",{formatter:A=>{const e=["FILE_HEADER","COMPRESSION_HEADER","MAPPED_SLICE_HEADER","UNMAPPED_SLICE_HEADER","EXTERNAL_DATA","CORE_DATA"][A];if(!e)throw new Error(`invalid block content type id ${A}`);return e}}).itf8("contentId").itf8("compressedSize").itf8("uncompressedSize"),maxLength:17},V={parser:(new $.i).uint32("crc32"),maxLength:4},Z=(new $.i).itf8("size").buffer("ents",{length:"size",formatter:A=>{function e(e,t){const r=A.toString("utf8",e,t),i=[];for(let A=0;A<r.length;A+=3)i.push(r.slice(A,A+3));return i}var t,r=[],i=0;for(t=0;t<A.length;t+=1)A[t]||(r.push(e(i,t)),i=t+1);return t>i&&r.push(e(i,t)),r}}),AA=(new $.i).uint8(null,{formatter:A=>!!A}),eA=(new $.i).itf8("mapSize").itf8("mapCount").array("ents",{length:"mapCount",type:(new $.i).string("key",{length:2,stripNull:!1}).choice("value",{tag:"key",choices:{MI:AA,UI:AA,PI:AA,RN:AA,AP:AA,RR:AA,SM:(new $.i).array(null,{type:"uint8",length:5}),TD:(new $.i).nest(null,{type:Z,formatter:A=>A.ents})}})});function tA(A){const e={};for(const{key:t,value:r}of A.ents)e[t]&&console.warn(`duplicate key ${t} in map`),e[t]=r;return e}const rA={cramFileDefinition:W,cramBlockHeader:j,cramBlockCrc32:V};function iA(A){return"number"==typeof A.refSeqId}const nA={cramUnmappedSliceHeader(A){let e=0,t=(new $.i).itf8("numRecords");return e+=5,A>=3?(t=t.ltf8("recordCounter"),e+=9):2===A&&(t=t.itf8("recordCounter"),e+=5),t=t.itf8("numBlocks").itf8("numContentIds").array("contentIds",{type:X,length:"numContentIds"}),e+=10,A>=2&&(t=t.array("md5",{type:"uint8",length:16}),e+=16),{parser:t,maxLength:A=>e+5*A}},cramMappedSliceHeader(A){let e=(new $.i).itf8("refSeqId").itf8("refSeqStart").itf8("refSeqSpan").itf8("numRecords"),t=20;return A>=3?(e=e.ltf8("recordCounter"),t+=9):2===A&&(e=e.itf8("recordCounter"),t+=5),e=e.itf8("numBlocks").itf8("numContentIds").array("contentIds",{type:X,length:"numContentIds"}).itf8("refBaseBlockId"),t+=15,A>=2&&(e=e.array("md5",{type:"uint8",length:16}),t+=16),{parser:e,maxLength:A=>t+5*A}},cramEncoding:A=>({parser:(new $.i).namely("cramEncoding").itf8("codecId").itf8("parametersBytes").choice("parameters",{tag:"codecId",choices:{0:new $.i,1:(new $.i).itf8("blockContentId"),2:(new $.i).itf8("offset").itf8("M"),3:$.i.start().itf8("numCodes").array("symbols",{length:"numCodes",type:X}).itf8("numLengths").array("bitLengths",{length:"numLengths",type:X}),4:$.i.start().nest("lengthsEncoding",{type:"cramEncoding"}).nest("valuesEncoding",{type:"cramEncoding"}),5:(new $.i).uint8("stopByte").itf8("blockContentId"),6:(new $.i).itf8("offset").itf8("length"),7:(new $.i).itf8("offset").itf8("K"),8:(new $.i).itf8("offset").itf8("log2m"),9:(new $.i).itf8("offset")}})}),cramDataSeriesEncodingMap(A){return(new $.i).itf8("mapSize").itf8("mapCount").array("ents",{length:"mapCount",type:(new $.i).string("key",{length:2,stripNull:!1}).nest("value",{type:this.cramEncoding(A).parser})})},cramTagEncodingMap(A){return(new $.i).itf8("mapSize").itf8("mapCount").array("ents",{length:"mapCount",type:(new $.i).itf8("key",{formatter:A=>String.fromCharCode(A>>16&255)+String.fromCharCode(A>>8&255)+String.fromCharCode(255&A)}).nest("value",{type:this.cramEncoding(A).parser})})},cramCompressionHeader(A){let e=new $.i;return e=e.nest("preservation",{type:eA,formatter:tA}).nest("dataSeriesEncoding",{type:this.cramDataSeriesEncodingMap(A),formatter:tA}).nest("tagEncoding",{type:this.cramTagEncodingMap(A),formatter:tA}),{parser:e}},cramContainerHeader1(A){let e=(new $.i).int32("length").itf8("refSeqId").itf8("refSeqStart").itf8("alignmentSpan").itf8("numRecords"),t=24;return A>=3?(e=e.ltf8("recordCounter"),t+=9):2===A&&(e=e.itf8("recordCounter"),t+=5),A>1&&(e=e.ltf8("numBases"),t+=9),e=e.itf8("numBlocks").itf8("numLandmarks"),t+=10,{parser:e,maxLength:t}},cramContainerHeader2(A){let e=(new $.i).itf8("numLandmarks").array("landmarks",{type:(new $.i).itf8(),length:"numLandmarks"}),t=0;return A>=3&&(e=e.uint32("crc32"),t=4),{parser:e,maxLength:A=>5+5*A+t}}};var sA=t(83503),oA=t.n(sA);class aA extends Error{}function gA(A,e,t){let r=0;if(e.bytePosition+(7-e.bitPosition+t)/8>A.length)throw new aA("read error during decoding. the file seems to be truncated.");for(let i=t;i;i--)r<<=1,r|=A[e.bytePosition]>>e.bitPosition&1,e.bitPosition-=1,e.bitPosition<0&&(e.bytePosition+=1),e.bitPosition&=7;return r}function IA(A,e,t=0,r=0){const{offset:i,result:n}=e.parse(A);return{...n,_endPosition:i+r,_size:i-t}}function CA(A,e){const t=A.prototype[e],r=`_memo_${e}`;A.prototype[e]=function(){if(!(r in this)){const A=t.call(this);this[r]=A,Promise.resolve(A).catch((()=>{delete this[r]}))}return this[r]}}var cA=t(28570),dA=t.n(cA);function hA(A){let e="";for(let t=0;t<A.length&&0!==A[t];t++)e+=String.fromCharCode(A[t]);return e}function QA(A,e){if("Z"===A)return hA(e);if("A"===A)return String.fromCharCode(e[0]);if("I"===A)return dA().fromBytesLE(e).toNumber();if("i"===A)return new Int32Array(e.buffer)[0];if("s"===A)return new Int16Array(e.buffer)[0];if("S"===A)return new Uint16Array(e.buffer)[0];if("c"===A)return new Int8Array(e.buffer)[0];if("C"===A)return e[0];if("f"===A)return new Float32Array(e.buffer)[0];if("H"===A)return Number.parseInt(hA(e).replace(/^0x/,""),16);if("B"===A)return function(A){const e=String.fromCharCode(A[0]),t=Int32Array.from(A.slice(1))[0],r=new Array(t);if(A=A.slice(5),"c"===e){const e=new Int8Array(A.buffer);for(let A=0;A<t;A+=1)r[A]=e[A]}else if("C"===e){const e=new Uint8Array(A.buffer);for(let A=0;A<t;A+=1)r[A]=e[A]}else if("s"===e){const e=new Int16Array(A.buffer);for(let A=0;A<t;A+=1)r[A]=e[A]}else if("S"===e){const e=new Uint16Array(A.buffer);for(let A=0;A<t;A+=1)r[A]=e[A]}else if("i"===e){const e=new Int32Array(A.buffer);for(let A=0;A<t;A+=1)r[A]=e[A]}else if("I"===e){const e=new Uint32Array(A.buffer);for(let A=0;A<t;A+=1)r[A]=e[A]}else{if("f"!==e)throw new Error("unknown type: "+e);{const e=new Float32Array(A.buffer);for(let A=0;A<t;A+=1)r[A]=e[A]}}return r}(e);throw new G(`Unrecognized tag type ${A}`)}function lA(A,e,t,r,i,n,s,o,a){let g=e("BF");const I=e("CF");if(!iA(r.parsedContent))throw new Error("slice header not mapped");const C=o>1&&-2===r.parsedContent.refSeqId?e("RI"):r.parsedContent.refSeqId,c=e("RL");let d=e("AP");t.APdelta&&(d+=s.lastAlignmentStart),s.lastAlignmentStart=d;const h=e("RG");let Q,l,B,f;if(t.readNamesIncluded&&(Q=hA(e("RN"))),p.isDetached(I)){const A=e("MF");let r;t.readNamesIncluded||(r=hA(e("RN")),Q=r);const i=e("NS"),n=e("NP");(A||i>-1)&&(l={mateFlags:A,mateSequenceId:i,mateAlignmentStart:n,mateReadName:r}),B=e("TS"),w.isUnmapped(A)&&(g=m.setMateUnmapped(g)),w.isOnNegativeStrand(A)&&(g=m.setMateReverseComplemented(g))}else p.isWithMateDownstream(I)&&(f=e("NF")+a+1);const u=e("TL");if(u<0)throw new G("invalid TL index");const E={},S=t.getTagNames(u),y=S.length;for(let e=0;e<y;e+=1){const r=S[e],o=r.slice(0,2),a=r.slice(2,3),g=t.getCodecForTag(r);if(!g)throw new G(`no codec defined for auxiliary tag ${r}`);const I=g.decode(A,i,n,s);E[o]=QA(a,I)}let D,N,k,b,q;if(m.isSegmentUnmapped(g))if(p.isDecodeSequenceAsStar(I))q=null,b=null;else{const A=new Array(c);for(let t=0;t<A.length;t+=1)A[t]=e("BA");if(q=String.fromCharCode(...A),p.isPreservingQualityScores(I)){b=new Array(c);for(let t=0;t<A.length;t+=1)b[t]=e("QS")}}else{const A=e("FN");if(A&&(D=function(A,e,t,r,i){let n=0,s=A-1;const o=new Array(e);function a([A,e]){const r=t(e);if("character"===A)return String.fromCharCode(r);if("string"===A){let A="";for(let e=0;e<r.byteLength;e++)A+=String.fromCharCode(r[e]);return A}return"numArray"===A?r.toArray():r}for(let A=0;A<e;A+=1){const e=String.fromCharCode(t("FC")),r=t("FP"),g={B:["character","BA"],S:["string",i>1?"SC":"IN"],X:["number","BS"],D:["number","DL"],I:["string","IN"],i:["character","BA"],b:["string","BB"],q:["numArray","QQ"],Q:["number","QS"],H:["number","HC"],P:["number","PD"],N:["number","RS"]}[e];if(!g)throw new G(`invalid read feature code "${e}"`);let I=a(g);const C={B:["number","QS"]}[e];C&&(I=[I,a(C)]),n+=r;const c=n;s+=r;const d=s;"D"===e||"N"===e?s+=I:"I"===e||"S"===e?s-=I.length:"i"===e&&(s-=1),o[A]={code:e,pos:c,refPos:d,data:I}}return o}(d,A,e,0,o)),N=c,D)for(const{code:A,data:e}of D)"D"===A||"N"===A?N+=e:"I"===A||"S"===A?N-=e.length:"i"===A&&(N-=1);if(Number.isNaN(N)&&(console.warn(`${Q||`${C}:${d}`} record has invalid read features`),N=c),k=e("MQ"),p.isPreservingQualityScores(I)){b=new Array(c);for(let A=0;A<b.length;A++)b[A]=e("QS")}}return{readLength:c,sequenceId:C,cramFlags:I,flags:g,alignmentStart:d,readGroupId:h,readName:Q,mateToUse:l,templateSize:B,mateRecordNumber:f,readFeatures:D,lengthOnRef:N,mappingQuality:k,qualityScores:b,readBases:q,tags:E}}function BA(A,e,t,r){if(!r)throw new G("could not resolve intra-slice mate pairs, file seems truncated or malformed");const i=!!(r.mate||void 0!==r.mateRecordNumber&&r.mateRecordNumber!==e);t.readName||(t.readName=String(t.uniqueId),r.readName=t.readName),t.mate={sequenceId:r.sequenceId,alignmentStart:r.alignmentStart,uniqueId:r.uniqueId},r.readName&&(t.mate.readName=r.readName),r.mate||void 0!==r.mateRecordNumber||(r.mate={sequenceId:t.sequenceId,alignmentStart:t.alignmentStart,uniqueId:t.uniqueId},t.readName&&(r.mate.readName=t.readName)),t.flags|=o,r.flags&g&&(t.flags|=I),t.flags&g&&(r.flags|=I),r.flags&C&&(t.flags|=c),t.flags&C&&(r.flags|=c),void 0===t.templateLength&&(i?function(A,e,t){const r=function e(t){const r=[t];if(void 0!==t.mateRecordNumber&&t.mateRecordNumber>=0){const i=A[t.mateRecordNumber];if(!i)throw new G("intra-slice mate record not found, this file seems malformed");r.push(...e(i))}return r}(t),i=r.map((A=>A.alignmentStart)),n=r.map((A=>A.alignmentStart+A.readLength-1)),s=Math.max(...n)-Math.min(...i)+1;s>=0&&r.forEach((A=>{if(void 0!==A.templateLength)throw new G("mate pair group has some members that have template lengths already, this file seems malformed");A.templateLength=s}))}(A,0,t):function(A,e){const t=Math.min(A.alignmentStart,e.alignmentStart),r=Math.max(A.alignmentStart+A.readLength-1,e.alignmentStart+e.readLength-1)-t+1;A.templateLength=r,e.templateLength=r}(t,r)),delete t.mateRecordNumber}class fA{constructor(A,e,t){this.container=A,this.containerPosition=e,this.file=A.file}async getHeader(){const A=await this.file.getSectionParsers(),e=await this.container.getHeader(),t=await this.file.readBlock(e._endPosition+this.containerPosition);if(void 0===t)throw new Error("block header undefined");if("MAPPED_SLICE_HEADER"===t.contentType){const r=IA(t.content,A.cramMappedSliceHeader.parser,0,e._endPosition);return{...t,parsedContent:r}}if("UNMAPPED_SLICE_HEADER"===t.contentType){const r=IA(t.content,A.cramUnmappedSliceHeader.parser,0,e._endPosition);return{...t,parsedContent:r}}throw new G(`error reading slice header block, invalid content type ${t.contentType}`)}async getBlocks(){const A=await this.getHeader();let e=A._endPosition;const t=new Array(A.parsedContent.numBlocks);for(let A=0;A<t.length;A+=1){const r=await this.file.readBlock(e);if(void 0===r)throw new Error("block undefined");t[A]=r,e=t[A]._endPosition}return t}async getCoreDataBlock(){return(await this.getBlocks())[0]}async _getBlocksContentIdIndex(){const A=await this.getBlocks(),e={};return A.forEach((A=>{"EXTERNAL_DATA"===A.contentType&&(e[A.contentId]=A)})),e}async getBlockByContentId(A){return(await this._getBlocksContentIdIndex())[A]}async getReferenceRegion(){const A=(await this.getHeader()).parsedContent;if(!iA(A))throw new Error("slice header not mapped");if(A.refSeqId<0)return;const e=await this.container.getCompressionScheme();if(void 0===e)throw new Error("compression scheme undefined");if(A.refBaseBlockId>=0){const e=await this.getBlockByContentId(A.refBaseBlockId);if(!e)throw new G("embedded reference specified, but reference block does not exist");return{seq:e.data.toString("utf8"),start:A.refSeqStart,end:A.refSeqStart+A.refSeqSpan-1,span:A.refSeqSpan}}if(e.referenceRequired||this.file.fetchReferenceSequenceCallback){if(!this.file.fetchReferenceSequenceCallback)throw new Error("reference sequence not embedded, and seqFetch callback not provided, cannot fetch reference sequence");const e=await this.file.fetchReferenceSequenceCallback(A.refSeqId,A.refSeqStart,A.refSeqStart+A.refSeqSpan-1);if(e.length!==A.refSeqSpan)throw new v("seqFetch callback returned a reference sequence of the wrong length");return{seq:e,start:A.refSeqStart,end:A.refSeqStart+A.refSeqSpan-1,span:A.refSeqSpan}}}getAllRecords(){return this.getRecords((()=>!0))}async _fetchRecords(){const{majorVersion:A}=await this.file.getDefinition(),e=await this.container.getCompressionScheme();if(void 0===e)throw new Error("compression scheme undefined");const t=await this.getHeader();if(void 0===t)throw new Error("slice header undefined");const r=await this._getBlocksContentIdIndex();if(A>1&&this.file.options.checkSequenceMD5&&iA(t.parsedContent)&&t.parsedContent.refSeqId>=0&&"0000000000000000"!==t.parsedContent.md5.join("")){const A=await this.getReferenceRegion();if(A){const{seq:e,start:r,end:i}=A,n=function(A){return oA()(A.toUpperCase().replaceAll(/[^\u0021-\u007e]/g,""))}(e),s=t.parsedContent.md5.map((A=>(A<16?"0":"")+A.toString(16))).join("");if(n!==s)throw new G(`MD5 checksum reference mismatch for ref ${t.parsedContent.refSeqId} pos ${r}..${i}. recorded MD5: ${s}, calculated MD5: ${n}`)}}const i=await this.getCoreDataBlock(),n={lastAlignmentStart:iA(t.parsedContent)?t.parsedContent.refSeqStart:0,coreBlock:{bitPosition:7,bytePosition:0},externalBlocks:{map:new Map,getCursor(A){let e=this.map.get(A);return void 0===e&&(e={bitPosition:7,bytePosition:0},this.map.set(A,e)),e}}},s=A=>{const t=e.getCodecForDataSeries(A);if(!t)throw new G(`no codec defined for ${A} data series`);return t.decode(this,i,r,n)};let o=new Array(t.parsedContent.numRecords);for(let a=0;a<o.length;a+=1)try{const g=lA(this,s,e,t,i,r,n,A,a);o[a]=new S({...g,uniqueId:t.contentPosition+t.parsedContent.recordCounter+a+1})}catch(A){if(A instanceof aA){console.warn("read attempted beyond end of buffer, file seems truncated."),o=o.filter((A=>!!A));break}throw A}for(let A=0;A<o.length;A+=1){const{mateRecordNumber:e}=o[A];void 0!==e&&e>=0&&BA(o,A,o[A],o[e])}return o}async getRecords(A){const e=this.container.filePosition+this.containerPosition;let t=this.file.featureCache.get(e.toString());t||(t=this._fetchRecords(),this.file.featureCache.set(e.toString(),t));const r=(await t).filter(A);if(r.length&&this.file.fetchReferenceSequenceCallback){const A=await this.getHeader();if(iA(A.parsedContent)&&(A.parsedContent.refSeqId>=0||-2===A.parsedContent.refSeqId)){const e=A.parsedContent.refSeqId>=0?A.parsedContent.refSeqId:void 0,t=await this.container.getCompressionScheme();if(void 0===t)throw new Error("compression scheme undefined");const i={};for(const A of r){const t=void 0!==e?e:A.sequenceId;let r=i[t];r||(r={id:t,start:A.alignmentStart,end:-1/0,seq:null},i[t]=r);const n=A.alignmentStart+(A.lengthOnRef||A.readLength)-1;n>r.end&&(r.end=n),A.alignmentStart<r.start&&(r.start=A.alignmentStart)}await Promise.all(Object.values(i).map((async A=>{-1!==A.id&&A.start<=A.end&&this.file.fetchReferenceSequenceCallback&&(A.seq=await this.file.fetchReferenceSequenceCallback(A.id,A.start,A.end))})));for(const A of r){const r=i[void 0!==e?e:A.sequenceId];if(null==r?void 0:r.seq){const e=r.seq;A.addReferenceSequence({...r,seq:e},t)}}}}return r}}"getHeader getBlocks _getBlocksContentIdIndex".split(" ").forEach((A=>CA(fA,A)));class uA{constructor(A,e){this.parameters=A,this.dataType=e}}class EA extends uA{constructor(A,e,t){if(super(A,e),this.instantiateCodec=t,"byteArray"!==e)throw new TypeError(`byteArrayLength does not support data type ${e}`)}decode(A,e,t,r){const i=this._getLengthCodec().decode(A,e,t,r),n=this._getDataCodec(),s=new Uint8Array(i);for(let o=0;o<i;o+=1)s[o]=n.decode(A,e,t,r);return s}_getLengthCodec(){const A=this.parameters.lengthsEncoding;return this.instantiateCodec(A,"int")}_getDataCodec(){const A=this.parameters.valuesEncoding;return this.instantiateCodec(A,"byte")}}"_getLengthCodec _getDataCodec".split(" ").forEach((A=>CA(EA,A)));const mA={1:class extends uA{constructor(A,e){if(super(A,e),"int"===this.dataType)this._decodeData=this._decodeInt;else{if("byte"!==this.dataType)throw new J(`${this.dataType} decoding not yet implemented by EXTERNAL codec`);this._decodeData=this._decodeByte}}decode(A,e,t,r){const{blockContentId:i}=this.parameters,n=t[i];if(!n)throw new G(`no block found with content ID ${i}`);const s=r.externalBlocks.getCursor(i);return this._decodeData(n,s)}_decodeInt(A,e){const[t,r]=function(A,e){let t=e;const r=A[t];let i;if(r<128?(i=r,t+=1):r<192?(i=16383&(r<<8|A[t+1]),t+=2):r<224?(i=2097151&(r<<16|A[t+1]<<8|A[t+2]),t+=3):r<240?(i=268435455&(r<<24|A[t+1]<<16|A[t+2]<<8|A[t+3]),t+=4):(i=(15&r)<<28|A[t+1]<<20|A[t+2]<<12|A[t+3]<<4|15&A[t+4],t+=5),t>A.length)throw new aA("Attempted to read beyond end of buffer; this file seems truncated.");return[i,t-e]}(A.content,e.bytePosition);return e.bytePosition=e.bytePosition+r,t}_decodeByte(A,e){if(e.bytePosition>=A.content.length)throw new aA("attempted to read beyond end of block. this file seems truncated.");return A.content[e.bytePosition++]}},3:class extends uA{constructor(A,e){if(super(A,e),this.codes={},this.codeBook={},this.sortedCodes=[],this.sortedValuesByBitCode=[],this.sortedBitCodes=[],this.sortedBitLengthsByBitCode=[],this.bitCodeToValue=[],!["byte","int"].includes(this.dataType))throw new TypeError(`${this.dataType} decoding not yet implemented by HUFFMAN_INT codec`);this.buildCodeBook(),this.buildCodes(),this.buildCaches(),0===this.sortedCodes[0].bitLength&&(this._decode=this._decodeZeroLengthCode)}buildCodeBook(){let A=new Array(this.parameters.numCodes);for(let e=0;e<this.parameters.numCodes;e+=1)A[e]={symbol:this.parameters.symbols[e],bitLength:this.parameters.bitLengths[e]};A=A.sort(((A,e)=>A.bitLength-e.bitLength||A.symbol-e.symbol)),this.codeBook={},A.forEach((A=>{this.codeBook[A.bitLength]||(this.codeBook[A.bitLength]=[]),this.codeBook[A.bitLength].push(A.symbol)}))}buildCodes(){this.codes={};let A=0,e=-1;Object.entries(this.codeBook).forEach((([t,r])=>{const i=parseInt(t,10);r.forEach((t=>{const r={bitLength:i,value:t,bitCode:0};e+=1;const n=i-A;if(e<<=n,r.bitCode=e,A+=n,function(A){let e=A-(A>>1)&1431655765;return e=(858993459&e)+(e>>2&858993459),16843009*(e+(e>>4)&252645135)>>24}(e)>i)throw new G("Symbol out of range");this.codes[t]=r}))}))}buildCaches(){this.sortedCodes=Object.values(this.codes).sort(((A,e)=>A.bitLength-e.bitLength||A.bitCode-e.bitCode)),this.sortedValuesByBitCode=this.sortedCodes.map((A=>A.value)),this.sortedBitCodes=this.sortedCodes.map((A=>A.bitCode)),this.sortedBitLengthsByBitCode=this.sortedCodes.map((A=>A.bitLength));const A=Math.max(...this.sortedBitCodes);this.bitCodeToValue=new Array(A+1).fill(-1);for(let A=0;A<this.sortedBitCodes.length;A+=1)this.bitCodeToValue[this.sortedCodes[A].bitCode]=A}decode(A,e,t,r){return this._decode(A,e,r.coreBlock)}_decodeZeroLengthCode(){return this.sortedCodes[0].value}_decode(A,e,t){const r=e.content;let i=0,n=0;for(let A=0;A<this.sortedCodes.length;A+=1){const e=this.sortedCodes[A].bitLength;n<<=e-i,n|=gA(r,t,e-i),i=e;{const t=this.bitCodeToValue[n];if(t>-1&&this.sortedBitLengthsByBitCode[t]===e)return this.sortedValuesByBitCode[t];for(let t=A;this.sortedCodes[t+1].bitLength===e&&t<this.sortedCodes.length;t+=1)A+=1}}throw new G("Huffman symbol not found.")}},4:EA,5:class extends uA{constructor(A,e){if(super(A,e),"byteArray"!==e)throw new TypeError(`byteArrayStop codec does not support data type ${e}`)}decode(A,e,t,r){const{blockContentId:i}=this.parameters,n=t[i];if(!n)throw new G(`no block found with content ID ${i}`);const s=r.externalBlocks.getCursor(i);return this._decodeByteArray(n,s)}_decodeByteArray(A,e){const t=A.content,{stopByte:r}=this.parameters,i=e.bytePosition;let n=e.bytePosition;for(;t[n]!==r&&n<t.length;){if(n===t.length)throw new aA("byteArrayStop reading beyond length of data buffer?");n+=1}return e.bytePosition=n+1,t.subarray(i,n)}},6:class extends uA{constructor(A,e){if(super(A,e),"int"!==this.dataType)throw new J(`${this.dataType} decoding not yet implemented by BETA codec`)}decode(A,e,t,r){return gA(e.content,r.coreBlock,this.parameters.length)-this.parameters.offset}},7:class extends uA{constructor(A,e){if(super(A,e),"int"!==this.dataType)throw new J(`${this.dataType} decoding not yet implemented by SUBEXP codec`)}decode(A,e,t,r){let i,n,s=0;for(;gA(e.content,r.coreBlock,1);)s+=1;return 0===s?(i=this.parameters.K,n=gA(e.content,r.coreBlock,i)):(i=s+this.parameters.K-1,n=1<<i|gA(e.content,r.coreBlock,i)),n-this.parameters.offset}},9:class extends uA{constructor(A,e){if(super(A,e),"int"!==this.dataType)throw new J(`${this.dataType} decoding not yet implemented by GAMMA codec`)}decode(A,e,t,r){let i=1;for(;0===gA(e.content,r.coreBlock,1);)i+=1;return(gA(e.content,r.coreBlock,i-1)|1<<i-1)-this.parameters.offset}}};function pA(A,e){const t=(r="ignore"===e?0:A.codecId,mA[r]);var r;if(!t)throw new J(`no codec implemented for codec ID ${A.codecId}`);return new t(A.parameters,e,pA)}const wA={BF:"int",CF:"int",RI:"int",RL:"int",AP:"int",RG:"int",MF:"int",NS:"int",NP:"int",TS:"int",NF:"int",TC:"byte",TN:"int",FN:"int",FC:"byte",FP:"int",BS:"byte",IN:"byteArray",SC:"byteArray",DL:"int",BA:"byte",BB:"byteArray",RS:"int",PD:"int",HC:"int",MQ:"int",RN:"byteArray",QS:"byte",QQ:"byteArray",TL:"int"};class SA{constructor(A){this.dataSeriesCodecCache={},this.tagCodecCache={},this.tagEncoding={},this.readNamesIncluded=A.preservation.RN,this.APdelta=A.preservation.AP,this.referenceRequired=!!A.preservation.RR,this.tagIdsDictionary=A.preservation.TD,this.substitutionMatrix=function(A){const e=new Array(5);for(let A=0;A<5;A+=1)e[A]=new Array(4);return e[0][A[0]>>6&3]="C",e[0][A[0]>>4&3]="G",e[0][A[0]>>2&3]="T",e[0][3&A[0]]="N",e[1][A[1]>>6&3]="A",e[1][A[1]>>4&3]="G",e[1][A[1]>>2&3]="T",e[1][3&A[1]]="N",e[2][A[2]>>6&3]="A",e[2][A[2]>>4&3]="C",e[2][A[2]>>2&3]="T",e[2][3&A[2]]="N",e[3][A[3]>>6&3]="A",e[3][A[3]>>4&3]="C",e[3][A[3]>>2&3]="G",e[3][3&A[3]]="N",e[4][A[4]>>6&3]="A",e[4][A[4]>>4&3]="C",e[4][A[4]>>2&3]="G",e[4][3&A[4]]="T",e}(A.preservation.SM),this.dataSeriesEncoding=A.dataSeriesEncoding,this.tagEncoding=A.tagEncoding,this.preservation=A.preservation,this._size=A._size,this._endPosition=A._endPosition}getCodecForTag(A){if(!this.tagCodecCache[A]){const e=this.tagEncoding[A];e&&(this.tagCodecCache[A]=pA(e,"byteArray"))}return this.tagCodecCache[A]}getTagNames(A){return this.tagIdsDictionary[A]}getCodecForDataSeries(A){let e=this.dataSeriesCodecCache[A];if(void 0===e){const t=this.dataSeriesEncoding[A];if(t){const r=wA[A];if(!r)throw new G(`data series name ${A} not defined in file compression header`);e=pA(t,r),this.dataSeriesCodecCache[A]=e}}return e}toJSON(){const A={};return Object.keys(this).forEach((e=>{e.endsWith("Cache")||(A[e]=this[e])})),A}}class yA{constructor(A,e){this.file=A,this.filePosition=e}getHeader(){return this._readContainerHeader(this.filePosition)}async getCompressionHeaderBlock(){if(!(await this.getHeader()).numRecords)return null;const A=await this.file.getSectionParsers(),e=await this.getFirstBlock();if(void 0===e)return;if("COMPRESSION_HEADER"!==e.contentType)throw new G(`invalid content type ${e.contentType} in what is supposed to be the compression header block`);const t=IA(e.content,A.cramCompressionHeader.parser,0,e.contentPosition);return{...e,parsedContent:t}}async getFirstBlock(){const A=await this.getHeader();return this.file.readBlock(A._endPosition)}async getCompressionScheme(){const A=await this.getCompressionHeaderBlock();if(A)return new SA(A.parsedContent)}getSlice(A,e){return new fA(this,A,e)}async _readContainerHeader(A){const e=await this.file.getSectionParsers(),{cramContainerHeader1:t,cramContainerHeader2:r}=e,{size:i}=await this.file.stat();if(A>=i)return;const n=Buffer.allocUnsafe(t.maxLength);await this.file.read(n,0,t.maxLength,A);const s=IA(n,t.parser),o=-128&(a=s.numLandmarks)?-16384&a?-2097152&a?-268435456&a?5:4:3:2:1;var a;if(A+s.length>=i)return void console.warn(`${this.file}: container header at ${A} indicates that the container has length ${s.length}, which extends beyond the length of the file. Skipping this container.`);const g=Buffer.allocUnsafe(r.maxLength(s.numLandmarks));await this.file.read(g,0,r.maxLength(s.numLandmarks),A+s._size-o);const I=IA(g,r.parser);return this.file.validateChecksums&&void 0!==I.crc32&&await this.file.checkCrc32(A,s._size+I._size-o-4,I.crc32,`container header beginning at position ${A}`),Object.assign(s,I,{_size:s._size+I._size-o,_endPosition:s._size+I._size-o+A})}}"getHeader getCompressionHeaderBlock getCompressionScheme".split(" ").forEach((A=>CA(yA,A)));var DA=t(88835),NA=t(71113);function kA(A,e,t){if(t)return t;if(A)return function(A){const{protocol:e,pathname:t}=DA.parse(A);return"file:"===e?new NA.LocalFile(unescape(function(A){if(null==A)throw new Error("Value must not be nullish.");return A}(t))):new NA.RemoteFile(A)}(A);if(e)return new NA.LocalFile(e);throw new Error("no url, path, or filehandle provided, cannot open")}function bA(A){const e=A.split(/\r?\n/),t=[];for(const A of e){const[e,...r]=A.split(/\t/);e&&t.push({tag:e.slice(1),data:r.map((A=>{const e=A.indexOf(":");return-1!==e?{tag:A.slice(0,e),value:A.slice(e+1)}:{tag:A,value:""}}))})}return t}class qA{constructor(A){var e;if(this.file=kA(A.url,A.path,A.filehandle),this.validateChecksums=!0,this.fetchReferenceSequenceCallback=A.seqFetch,this.options={checkSequenceMD5:A.checkSequenceMD5,cacheSize:null!==(e=A.cacheSize)&&void 0!==e?e:2e4},this.featureCache=new(b())({maxSize:this.options.cacheSize}),function(){const A=new Uint32Array([287454020]),e=new Uint8Array(A.buffer);return 68===e[0]?0:17===e[0]?1:2}()>0)throw new Error("Detected big-endian machine, may be unable to run")}read(A,e,t,r){return this.file.read(A,e,t,r)}stat(){return this.file.stat()}async getDefinition(){const A=Buffer.allocUnsafe(W.maxLength);await this.file.read(A,0,W.maxLength,0);const e=W.parser.parse(A).result;if(2!==e.majorVersion&&3!==e.majorVersion)throw new J(`CRAM version ${e.majorVersion} not supported`);return e}async getSamHeader(){const A=await this.getContainerById(0);if(!A)throw new G("file contains no containers");const e=await A.getFirstBlock();if(void 0===e)return bA("");const t=e.content,r=t.readInt32LE(0),i=t.toString("utf8",4,4+r);return this.header=i,bA(i)}async getHeaderText(){return await this.getSamHeader(),this.header}async getSectionParsers(){const{majorVersion:A}=await this.getDefinition();return function(A){const e=Object.assign({},rA);return Object.keys(nA).forEach((t=>{e[t]=nA[t](A)})),e}(A)}async getContainerById(A){const e=await this.getSectionParsers();let t=e.cramFileDefinition.maxLength;const{size:r}=await this.file.stat(),{cramContainerHeader1:i}=e;let n;for(let e=0;e<=A;e+=1){if(t+i.maxLength+8>=r)return;n=this.getContainerAtPosition(t);const s=await n.getHeader();if(!s)throw new G(`container ${A} not found in file`);if(0===e){t=s._endPosition;for(let A=0;A<s.numBlocks;A+=1){const A=await this.readBlock(t);if(void 0===A)return;t=A._endPosition}}else t+=s._size+s.length}return n}async checkCrc32(A,e,t,r){const i=Buffer.allocUnsafe(e);await this.file.read(i,0,e,A);const n=N.A.unsigned(i);if(n!==t)throw new G(`crc mismatch in ${r}: recorded CRC32 = ${t}, but calculated CRC32 = ${n}`)}async containerCount(){const A=await this.getSectionParsers(),{size:e}=await this.file.stat(),{cramContainerHeader1:t}=A;let r=0,i=A.cramFileDefinition.maxLength;for(;i+t.maxLength+8<e;){const A=await this.getContainerAtPosition(i).getHeader();if(!A)break;if(0===r){i=A._endPosition;for(let e=0;e<A.numBlocks;e+=1){const A=await this.readBlock(i);if(void 0===A)return;i=A._endPosition}}else i+=A._size+A.length;r+=1}return r}getContainerAtPosition(A){return new yA(this,A)}async readBlockHeader(A){const e=await this.getSectionParsers(),{cramBlockHeader:t}=e,{size:r}=await this.file.stat();if(A+t.maxLength>=r)return;const i=Buffer.allocUnsafe(t.maxLength);return await this.file.read(i,0,t.maxLength,A),IA(i,t.parser,0,A)}async _parseSection(A,e,t=A.maxLength,r=void 0){let i;if(r)i=r;else{const{size:A}=await this.file.stat();if(e+t>=A)return;i=Buffer.allocUnsafe(t),await this.file.read(i,0,t,e)}const n=IA(i,A.parser,0,e);if(n._size!==t)throw new G(`section read error: requested size ${t} does not equal parsed size ${n._size}`);return n}async _uncompress(A,e,t){if("gzip"===A)D(e).copy(t);else if("bzip2"===A){const A=R().array(e);let r,i=R().header(A),n=0;do{r=R().decompress(A,i),-1!=r&&(Buffer.from(r).copy(t,n),n+=r.length,i-=r.length)}while(-1!=r)}else if("lzma"===A){const A=new Response(new H.XzReadableStream((r=e,new ReadableStream({start(A){A.enqueue(r),A.close()}}))));Buffer.from(await A.arrayBuffer()).copy(t)}else if("rans"===A)!function(A,e,t=0){if(0===A.length)return e.fill(0),e;const r=new O(A,t),i=r.get();if(0!==i&&1!==i)throw new G(`Invalid rANS order ${i}`);if(r.getInt()!==r.remaining()-4)throw new G("Incorrect input length.");const n=r.getInt(),s=new O(e||Buffer.allocUnsafe(n));if(s.length<n)throw new G(`Output buffer too small to fit ${n} bytes.`);switch(i){case 0:return function(A,e){const t=new z.AriDecoder,r=new Array(256);for(let A=0;A<r.length;A+=1)r[A]=new z.Symbol;return function(A,e,t){let r=0,i=0,n=255&A.get();do{null==e.fc[n]&&(e.fc[n]=new z.FC),e.fc[n].F=255&A.get(),e.fc[n].F>=128&&(e.fc[n].F&=-129,e.fc[n].F=(127&e.fc[n].F)<<8|255&A.get()),e.fc[n].C=i,z.symbolInit(t[n],e.fc[n].C,e.fc[n].F),e.R||(e.R=new Array(Y)),e.R.fill(n,i,i+e.fc[n].F),i+=e.fc[n].F,0===r&&n+1===(255&A.getByteAt(A.position()))?(n=255&A.get(),r=255&A.get()):0!==r?(r-=1,n+=1):n=255&A.get()}while(0!==n);T(i<Y)}(A,t,r),function(A,e,t,r){let i=A.getInt(),n=A.getInt(),s=A.getInt(),o=A.getInt();const a=r.remaining(),g=-4&a;for(let a=0;a<g;a+=4){const g=e.R[z.get(i,P)],I=e.R[z.get(n,P)],C=e.R[z.get(s,P)],c=e.R[z.get(o,P)];r.putAt(a,g),r.putAt(a+1,I),r.putAt(a+2,C),r.putAt(a+3,c),i=z.advanceSymbolStep(i,t[255&g],P),n=z.advanceSymbolStep(n,t[255&I],P),s=z.advanceSymbolStep(s,t[255&C],P),o=z.advanceSymbolStep(o,t[255&c],P),i=z.renormalize(i,A),n=z.renormalize(n,A),s=z.renormalize(s,A),o=z.renormalize(o,A)}let I;switch(r.setPosition(g),3&a){case 0:break;case 1:I=e.R[z.get(i,P)],z.advanceSymbol(i,A,t[255&I],P),r.put(I);break;case 2:I=e.R[z.get(i,P)],z.advanceSymbol(i,A,t[255&I],P),r.put(I),I=e.R[z.get(n,P)],z.advanceSymbol(n,A,t[255&I],P),r.put(I);break;case 3:I=e.R[z.get(i,P)],z.advanceSymbol(i,A,t[255&I],P),r.put(I),I=e.R[z.get(n,P)],z.advanceSymbol(n,A,t[255&I],P),r.put(I),I=e.R[z.get(s,P)],z.advanceSymbol(s,A,t[255&I],P),r.put(I);break;default:throw new G("invalid output size encountered during rANS decoding")}r.setPosition(0)}(A,t,r,e),e}(r,s);case 1:return function(A,e){const t=new Array(256);for(let A=0;A<t.length;A+=1)t[A]=new z.AriDecoder;const r=new Array(256);for(let A=0;A<r.length;A+=1){r[A]=new Array(256);for(let e=0;e<r[A].length;e+=1)r[A][e]=new z.Symbol}return function(A,e,t){let r=0,i=255&A.get();do{let n=0,s=0,o=255&A.get();null==e[i]&&(e[i]=new z.AriDecoder);do{null==e[i].fc[o]&&(e[i].fc[o]=new z.FC),e[i].fc[o].F=255&A.get(),e[i].fc[o].F>=128&&(e[i].fc[o].F&=-129,e[i].fc[o].F=(127&e[i].fc[o].F)<<8|255&A.get()),e[i].fc[o].C=s,0===e[i].fc[o].F&&(e[i].fc[o].F=Y),null==t[i][o]&&(t[i][o]=new z.RansDecSymbol),z.symbolInit(t[i][o],e[i].fc[o].C,e[i].fc[o].F),null==e[i].R&&(e[i].R=new Array(Y)),e[i].R.fill(o,s,s+e[i].fc[o].F),s+=e[i].fc[o].F,T(s<=Y),0===n&&o+1===(255&A.getByteAt(A.position()))?(o=255&A.get(),n=255&A.get()):0!==n?(n-=1,o+=1):o=255&A.get()}while(0!==o);0===r&&i+1===(255&A.getByteAt(A.position()))?(i=255&A.get(),r=255&A.get()):0!==r?(r-=1,i+=1):i=255&A.get()}while(0!==i)}(A,t,r),function(A,e,t,r){const i=e.remaining();let n=A.getInt(),s=A.getInt(),o=A.getInt(),a=A.getInt();const g=i>>2;let I=0,C=g,c=2*g,d=3*g,h=0,Q=0,l=0,B=0;for(;I<g;I+=1,C+=1,c+=1,d+=1){const i=255&t[h].R[z.get(n,P)],g=255&t[Q].R[z.get(s,P)],f=255&t[l].R[z.get(o,P)],u=255&t[B].R[z.get(a,P)];e.putAt(I,i),e.putAt(C,g),e.putAt(c,f),e.putAt(d,u),n=z.advanceSymbolStep(n,r[h][i],P),s=z.advanceSymbolStep(s,r[Q][g],P),o=z.advanceSymbolStep(o,r[l][f],P),a=z.advanceSymbolStep(a,r[B][u],P),n=z.renormalize(n,A),s=z.renormalize(s,A),o=z.renormalize(o,A),a=z.renormalize(a,A),h=i,Q=g,l=f,B=u}for(;d<i;d+=1){const i=255&t[B].R[z.get(a,P)];e.putAt(d,i),a=z.advanceSymbol(a,A,r[B][i],P),B=i}}(A,e,t,r),e}(r,s);default:throw new G(`Invalid rANS order: ${i}`)}}(e,t);else if("rans4x16"===A)F().r4x16_uncompress(e,t);else if("arith"===A)F().arith_uncompress(e,t);else if("fqzcomp"===A)F().fqzcomp_uncompress(e,t);else{if("tok3"!==A)throw new J(`${A} decompression not yet implemented`);F().tok3_uncompress(e,t)}var r}async readBlock(A){const{majorVersion:e}=await this.getDefinition(),t=await this.getSectionParsers(),r=await this.readBlockHeader(A);if(void 0===r)return;const i=r._endPosition,n=Buffer.allocUnsafe(r.uncompressedSize),s={...r,_endPosition:i,contentPosition:i,content:n};if("raw"!==r.compressionMethod){const A=Buffer.allocUnsafe(r.compressedSize);await this.read(A,0,r.compressedSize,i),await this._uncompress(r.compressionMethod,A,n)}else await this.read(n,0,r.uncompressedSize,i);if(e>=3){const e=await this._parseSection(t.cramBlockCrc32,i+r.compressedSize);if(void 0===e)return;s.crc32=e.crc32,this.validateChecksums&&await this.checkCrc32(A,r._size+r.compressedSize,e.crc32,"block data"),s._endPosition=e._endPosition,s._size=s.compressedSize+t.cramBlockCrc32.maxLength}else s._endPosition=i+s.compressedSize,s._size=s.compressedSize;return s}}"getDefinition getSectionParsers getSamHeader".split(" ").forEach((A=>CA(qA,A)));var FA=t(98802),LA=t.n(FA);function RA(A,e){const[t,r,i,n,s,o]=e;A[t]||(A[t]=[]),A[t].push({start:r,span:i,containerStart:n,sliceStart:s,sliceBytes:o})}class HA{constructor(A){this.filehandle=kA(A.url,A.path,A.filehandle),this._parseCache=new(LA())({cache:new(b())({maxSize:1}),fill:(A,e)=>this.parseIndex()})}parseIndex(){const A={};return this.filehandle.readFile().then((A=>31===A[0]&&139===A[1]?D(A):A)).then((e=>{if(e.length>4&&21578050===e.readUInt32LE(0))throw new G("invalid .crai index file. note: file appears to be a .bai index. this is technically legal but please open a github issue if you need support");let t=[],r="";for(const i of e)if(i>=48&&i<=57||!r&&45===i)r+=String.fromCharCode(i);else if(9===i)t.push(Number.parseInt(r,10)),r="";else if(10===i)t.push(Number.parseInt(r,10)),r="",RA(A,t),t=[];else if(13!==i&&32!==i)throw new G("invalid .crai index file");return r&&t.push(Number.parseInt(r,10)),6===t.length&&RA(A,t),Object.entries(A).forEach((([e,t])=>{A[e]=t.sort(((A,e)=>A.start-e.start||A.span-e.span))})),A}))}getIndex(A={}){return this._parseCache.get("index",null,A.signal)}async hasDataForReferenceSequence(A){return!!(await this.getIndex())[A]}async getEntriesForRange(A,e,t){const r=(await this.getIndex())[A];if(!r)return[];const i=A=>{const r=A.start,i=A.start+A.span;return r>t?-1:i<=e?1:0},n=[];for(const A of r)0===i(A)&&n.push(A);return n}}class _A{constructor(A){var e;if(this.cram=null!==(e=A.cram)&&void 0!==e?e:new qA({url:A.cramUrl,path:A.cramPath,filehandle:A.cramFilehandle,seqFetch:A.seqFetch,checkSequenceMD5:A.checkSequenceMD5,cacheSize:A.cacheSize}),!(this.cram instanceof qA))throw new Error("invalid arguments: no cramfile");if(this.index=A.index,!this.index.getEntriesForRange)throw new Error("invalid arguments: not an index");this.fetchSizeLimit=A.fetchSizeLimit||3e6}async getRecordsForRange(A,e,t,r={}){if(r.viewAsPairs=r.viewAsPairs||!1,r.pairAcrossChr=r.pairAcrossChr||!1,r.maxInsertSize=r.maxInsertSize||2e5,"string"==typeof A)throw new J("string sequence names not yet supported");const i=A,n=await this.index.getEntriesForRange(i,e,t),s=n.map((A=>A.sliceBytes)).reduce(((A,e)=>A+e),0);if(s>this.fetchSizeLimit)throw new M(`data size of ${s.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);const o=r=>r.sequenceId===A&&r.alignmentStart<=t&&void 0!==r.lengthOnRef&&r.alignmentStart+r.lengthOnRef-1>=e,a=await Promise.all(n.map((A=>this.getRecordsInSlice(A,o))));let g=Array.prototype.concat(...a);if(r.viewAsPairs){const A={},e={};for(const t of g){const r=t.readName;if(void 0===r)throw new Error("readName undefined");const i=t.uniqueId;A[r]||(A[r]=0),A[r]+=1,e[i]=1}const t={};Object.entries(A).forEach((([A,e])=>{1===e&&(t[A]=!0)}));const n=[];for(const A of g){const e=A.readName;if(void 0===e)throw new Error("readName undefined");if(t[e]&&A.mate&&(A.mate.sequenceId===i||r.pairAcrossChr)&&Math.abs(A.alignmentStart-A.mate.alignmentStart)<r.maxInsertSize){const e=this.index.getEntriesForRange(A.mate.sequenceId,A.mate.alignmentStart,A.mate.alignmentStart+1);n.push(e)}}const s=await Promise.all(n);let o=[];for(const A of s)o.push(...A);o=o.sort(((A,e)=>A.toString().localeCompare(e.toString()))).filter(((A,e,t)=>!e||A.toString()!==t[e-1].toString()));const a=[],I=[],C=o.map((A=>A.sliceBytes)).reduce(((A,e)=>A+e),0);if(C>this.fetchSizeLimit)throw new Error(`mate data size of ${C.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);o.forEach((A=>{let r=this.cram.featureCache.get(A.toString());r||(r=this.getRecordsInSlice(A,(()=>!0)),this.cram.featureCache.set(A.toString(),r)),a.push(r);const i=r.then((A=>{const r=[];for(const i of A){if(void 0===i.readName)throw new Error("readName undefined");t[i.readName]&&!e[i.uniqueId]&&r.push(i)}return r}));I.push(i)}));const c=await Promise.all(I);if(c.length){const A=c.reduce(((A,e)=>A.concat(e)));g=g.concat(A)}}return g}getRecordsInSlice({containerStart:A,sliceStart:e,sliceBytes:t},r){return this.cram.getContainerAtPosition(A).getSlice(e,t).getRecords(r)}hasDataForReferenceSequence(A){return this.index.hasDataForReferenceSequence(A)}}var JA=t(2340),GA=t(7562),MA=t(11375),vA=t(34105),PA=t(9084),YA=t(48825);class xA{constructor(A,e){this.record=A,this._store=e}_get_name(){return this.record.readName}_get_start(){return this.record.alignmentStart-1}_get_end(){var A;return this.record.alignmentStart+(null!==(A=this.record.lengthOnRef)&&void 0!==A?A:1)-1}_get_cram_read_features(){return this.record.readFeatures}_get_type(){return"match"}_get_score(){return this.record.mappingQuality}_get_flags(){return this.record.flags}_get_strand(){return this.record.isReverseComplemented()?-1:1}_read_group_id(){var A;return null===(A=this._store.samHeader.readGroups)||void 0===A?void 0:A[this.record.readGroupId]}_get_qual(){return(this.record.qualityScores||[]).join(" ")}qualRaw(){return this.record.qualityScores}_get_refName(){return this._store.refIdToName(this.record.sequenceId)}_get_is_paired(){return!!this.record.mate}_get_pair_orientation(){return this.record.isPaired()?this.record.getPairOrientation():void 0}_get_template_length(){return this.record.templateLength||this.record.templateSize}_get_next_ref(){return this.record.mate?this._store.refIdToName(this.record.mate.sequenceId):void 0}_get_next_segment_position(){return this.record.mate?`${this._store.refIdToName(this.record.mate.sequenceId)}:${this.record.mate.alignmentStart}`:void 0}_get_next_pos(){var A;return null===(A=this.record.mate)||void 0===A?void 0:A.alignmentStart}_get_tags(){const A=this._read_group_id(),{tags:e}=this.record;return void 0!==A?{...e,RG:A}:e}_get_seq(){return this.record.getReadBases()}_get_CIGAR(){return function(A,e,t,r){let i="",n="",s="M",o=0;if(!r)return"";const a=r.seq,g=r.start;let I=e,C=0,c=0;if(void 0!==A)for(const{code:e,refPos:t,sub:r,data:d}of A)if(C=t-I,i+=a.slice(I-g,t-g),I=t,c>0&&C&&(n+=`${c}I`,c=0),o&&"M"!==s&&(n+=`${o}${s}`,o=0),C&&(s="M",o+=C),"b"===e){const A=d.split(","),e=String.fromCharCode(...A);i+=e,I+=e.length,o+=e.length}else"B"===e||"X"===e?(i+=r,I++,o++):"D"===e||"N"===e?(I+=d,o&&(n+=`${o}${s}`),n+=d+e,o=0):"I"===e||"S"===e?(i+=d,o&&(n+=`${o}${s}`),n+=d.length+e,o=0):"i"===e?(o&&(n+=`${o}${s}`),c++,i+=d,o=0):"P"===e?(o&&(n+=`${o}${s}`),n+=`${d}P`):"H"===e&&(o&&(n+=`${o}${s}`),n+=`${d}H`,o=0);else C=t-i.length;return i.length!==t&&(C=t-i.length,i+=a.slice(I-g,I-g+C),o&&"M"!==s&&(n+=`${o}${s}`,o=0),s="M",o+=C),C&&c>0&&(n+=`${c}I`),o&&(n+=`${o}${s}`),n}(this.record.readFeatures,this.record.alignmentStart,this.record.readLength,this.record._refRegion)}tags(){return Object.getOwnPropertyNames(xA.prototype).filter((A=>A.startsWith("_get_")&&"_get_mismatches"!==A&&"_get_cram_read_features"!==A)).map((A=>A.replace("_get_","")))}id(){return`${this._store.id}-${this.record.uniqueId}`}get(A){const e=`_get_${A}`;if(this[e])return this[e]()}parent(){}children(){}set(){}pairedFeature(){return!1}_get_clipPos(){const A=this.get("mismatches");if(A.length){const e=-1===this.get("strand")?A.at(-1):A[0],{type:t,cliplen:r}=e;if("softclip"===t||"hardclip"===t)return r}return 0}toJSON(){return{...Object.fromEntries(this.tags().map((A=>[A,this.get(A)])).filter((A=>void 0!==A[1]))),uniqueId:this.id()}}_get_mismatches(){const A=this.record.readFeatures,e=this.qualRaw();return function(A,e,t){if(!A)return[];const r=new Array(A.length);let i=0,n=0,s=0,o=0,a=e;for(const{refPos:g,code:I,pos:C,data:c,sub:d,ref:h}of A)if(o=s-a,a=s,o&&n>0&&(r[i++]={start:s,type:"insertion",base:`${n}`,length:0},n=0),s=g-1-e,"X"===I)r[i++]={start:s,length:1,base:d,qual:null==t?void 0:t[C-1],altbase:null==h?void 0:h.toUpperCase(),type:"mismatch"};else if("I"===I)r[i++]={start:s,type:"insertion",base:`${c.length}`,length:0};else if("N"===I)r[i++]={type:"skip",length:c,start:s,base:"N"};else if("S"===I){const A=c.length;r[i++]={start:s,type:"softclip",base:`S${A}`,cliplen:A,length:1}}else if("P"===I);else if("H"===I){const A=c;r[i++]={start:s,type:"hardclip",base:`H${A}`,cliplen:A,length:1}}else"D"===I?r[i++]={type:"deletion",length:c,start:s,base:"*"}:"b"===I||"q"===I||"B"===I||"i"===I&&n++;return o&&n>0&&(r[i++]={start:s,type:"insertion",base:`${n}`,length:0},n=0),r.slice(0,i)}(A,this.get("start"),e)}}class KA extends JA.BaseFeatureDataAdapter{constructor(){super(...arguments),this.samHeader={},this.seqIdToOriginalRefName=[]}async configurePre(){const A=this.getConf("cramLocation"),e=this.getConf("craiLocation"),t=this.pluginManager,r=new _A({cramFilehandle:(0,MA.openLocation)(A,t),index:new HA({filehandle:(0,MA.openLocation)(e,t)}),seqFetch:(...A)=>this.seqFetch(...A),checkSequenceMD5:!1,fetchSizeLimit:2e8});if(!this.getSubAdapter)throw new Error("Error getting subadapter");const i=this.getConf("sequenceAdapter");if(!i)throw new Error("no sequenceAdapter supplied to CramAdapter config");return{cram:r,sequenceAdapter:(await this.getSubAdapter(i)).dataAdapter}}async configure(){return this.configureP||(this.configureP=this.configurePre().catch((A=>{throw this.configureP=void 0,A}))),this.configureP}async getHeader(A){const{cram:e}=await this.configure();return e.cram.getHeaderText()}async seqFetch(A,e,t){e-=1;const{sequenceAdapter:r}=await this.configure(),i=this.refIdToOriginalName(A)||this.refIdToName(A);if(!i)throw new Error("unknown");const n=(await(0,YA._)(r.getFeatures({refName:i,start:e,end:t,assemblyName:""}).pipe((0,PA.$)()))).sort(((A,e)=>A.get("start")-e.get("start"))).map((A=>{const r=A.get("start"),i=A.get("end"),n=Math.max(e-r,0),s=Math.min(t-r,i-r)-n;return(A.get("seq")||A.get("residues")).slice(n,n+s)})).join(""),s=t-e;if(n.length!==s)throw new Error(`fetching ${i}:${(0,GA.toLocale)(e-1)}-${(0,GA.toLocale)(t)} returned ${(0,GA.toLocale)(n.length)} bases, should have returned ${(0,GA.toLocale)(s)}`);return n}async setupPre(A){const{statusCallback:e=(()=>{})}=A||{};return(0,GA.updateStatus)("Downloading index",e,(async()=>{const A=await this.configure(),{cram:e}=A,t=await e.cram.getSamHeader(),r=[],i={};t.filter((A=>"SQ"===A.tag)).forEach(((A,e)=>{const t=A.data.find((A=>"SN"===A.tag));if(t){const A=t.value;i[A]=e,r[e]=A}}));const n=t.filter((A=>"RG"===A.tag)).map((A=>{var e;return null===(e=A.data.find((A=>"ID"===A.tag)))||void 0===e?void 0:e.value})),s={idToName:r,nameToId:i,readGroups:n};return this.samHeader=s,{samHeader:s,...A}}))}async setup(A){return this.setupP||(this.setupP=this.setupPre(A).catch((A=>{throw this.setupP=void 0,A}))),this.setupP}async getRefNames(A){const{samHeader:e}=await this.setup(A);if(!e.idToName)throw new Error("CRAM file has no header lines");return e.idToName}refNameToId(A){return this.samHeader.nameToId?this.samHeader.nameToId[A]:this.seqIdToRefName?this.seqIdToRefName.indexOf(A):void 0}refIdToName(A){var e,t;return(null===(e=this.samHeader.idToName)||void 0===e?void 0:e[A])||(null===(t=this.seqIdToRefName)||void 0===t?void 0:t[A])}refIdToOriginalName(A){return this.seqIdToOriginalRefName[A]}getFeatures(A,e){const{signal:t,filterBy:r,statusCallback:i=(()=>{})}=e||{},{refName:n,start:s,end:o,originalRefName:a}=A;return(0,vA.ObservableCreate)((async A=>{const{cram:g,samHeader:I}=await this.setup(e),C=this.refNameToId(n);if(void 0===C)return console.warn("Unknown refName",n),void A.complete();a&&(this.seqIdToOriginalRefName[C]=a);const c=await(0,GA.updateStatus)("Downloading alignments",i,(()=>g.getRecordsForRange(C,s,o)));(0,GA.checkAbortSignal)(t),await(0,GA.updateStatus)("Processing alignments",i,(()=>{var e;const{flagInclude:t=0,flagExclude:i=0,tagFilter:n,readName:s}=r||{};for(const r of c){const o=r.flags;if((o&t)===t||o&i){if(n){const A="RG"===n.tag?null===(e=I.readGroups)||void 0===e?void 0:e[r.readGroupId]:r.tags[n.tag];if(!("*"===n.value?void 0!==A:`${A}`===n.value))continue}s&&r.readName!==s||A.next(this.cramRecordToFeature(r))}}A.complete()}))}),t)}freeResources(){}cramRecordToFeature(A){return new xA(A,this)}async getMultiRegionFeatureDensityStats(A,e){return{bytes:await this.bytesForRegions(A,e),fetchSizeLimit:this.getConf("fetchSizeLimit")}}async bytesForRegions(A,e){const{cram:t}=await this.configure();return(await Promise.all(A.map((A=>{const{refName:e,start:r,end:i}=A,n=this.refNameToId(e);return void 0!==n?t.index.getEntriesForRange(n,r,i):[{sliceBytes:0}]})))).flat().reduce(((A,e)=>A+e.sliceBytes),0)}}},41307:function(A,e,t){var r;r=A=>(()=>{"use strict";var e=[,A=>{A.exports="data:application/wasm;base64,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IgENAAsLIAJCf4UL1RACDH8CfgJAAkAgACgCJEUNACAAKAIAIQIMAQtBACECIABBADoAKCAAQgA3AwAgAEIANwMYIABByABqQQBB5AAQhoCAgAAaIABBrAFqQQw2AgALIAAgASgCBCIDNgIQIABBsAFqIQQgAEHgAGohBSAAQcgAaiEGIABBtgFqIQcgAEGoAWohCCABKAIQIQkCQAJAAkACQANAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOCgECAAQFBgcICQoPCyABKAIAIQogACgCqAEhAiAAKAKsASELIAEoAgQhDCABKAIIIQ0MAgsgCCAAKAKoASIMakEIaiABKAIAIAEoAgQiAmogASgCCCACayICIAAoAqwBIAxrIgwgAiAMSRsiAhCHgICAABogASABKAIEIAJqNgIEQQAhDCAAQQAgACgCqAEgAmoiAiACIAAoAqwBIgtGGzYCqAEgAiALRw0RIABBATYCAAJAIARBqIiAgABBBhCEgICAAEUNAEEFIQwMEgsgB0ECQQAQjYCAgAAgACgAuAFHDRBBBiEMIActAAANESAAIAAtALcBIgI2AiAgAkEESw0RQQEgAnRBE3FFDRELIAEoAgQiDCABKAIIIg1GDQ4CQCABKAIAIgogDGotAAAiCw0AIAAgDDYCECABIAxBAWo2AgRBBiECDAwLQQAhAiAAQQA2AqgBIABBAjYCACAAIAtBAnRBBGoiCzYCrAEgACALNgJACyAIIAJqQQhqIAogDGogDSAMayIMIAsgAmsiAiAMIAJJGyICEIeAgIAAGiABIAIgASgCBGo2AgRBACEMIABBACAAKAKoASACaiICIAIgACgCrAEiC0YbNgKoASACIAtHDQ8gACACQXxqIgI2AqwBQQchDCAEIAJBABCNgICAACAAIAAoAqwBIgtqQbABaigAAEcNDyAAQQI2AqgBIAAtALEBIgJBP3ENDAJAAkAgAkHAAHFFDQAgACAEIAggCxCRgICAAEEBRw0RIAAgACkDCDcDMCAALQCxASECDAELIABCfzcDMAtCfyEOAkAgAkEYdEEYdUF/Sg0AIAAgBCAIIAAoAqwBEJGAgIAAQQFHDRAgACkDCCEOCyAAIA43AzggACgCrAEiDSAAKAKoASICa0ECSQ0PIAAgAkEBaiIKNgKoASAIIAJqQQhq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IgM2AhAgACAOQQh0IAAoAgwgCWotAAByIg42AgQgAyEJCwJAAkAgDiALQQt2IA8vAQAiCmwiA08iEg0AIAAgAzYCACAKQYAQIAprQQV2aiEKDAELIAAgDiADayIONgIEIAAgCyADayIDNgIAIAogCkEFdmshCkEAIQ0LIA8gCjsBACANIBFzIQ0gBEEBdCASciIEQYACSQ0ACwsgACACQQFqNgIgIAAoAhggAmogBDoAAAJAIAAoAiQgACgCICICTw0AIAAgAjYCJAtBACEDAkAgACgCZCIEQQRJDQACQCAEQQlLDQAgBEF9aiEDDAELIARBemohAwsgACADNgJkDAELIAAgDiADayIONgIEIAAgBCADayIDNgIAIA0gDyAPQQV2azsBACAAIApBAXRqIg9B+ANqIQQCQAJAIANB////B00NACAJIQoMAQsgACADQQh0IgM2AgAgACAJQQFqIgo2AhAgACAOQQh0IAAoAgwgCWotAAByIg42AgQLAkACQCAOIANBC3YgBC8BACINbCIJSQ0AIAAgDiAJayIONgIEIAAgAyAJayIDNgIAIAQgDSANQQV2azsBACAPQZAEaiENAkACQCADQf///wdNDQAgCiEQDAELIAAgA0EIdCIDNgIAIAAgCkEBaiIQNgIQIAAgDkEIdCAAKAIMIApqLQAAciIONgIECwJAAkAgDiADQQt2IA0vAQAiCWwiBE8NACANIAlBgBAgCWtBBXZqOwEAIAxB2ARqIQMCQCAEQf///wdLDQAgACAEQQh0IgQ2AgAgACAQQQFqNgIQIAAgDkEIdCAAKAIMIBBqLQAAciIONgIECwJAIA4gBEELdiADLwEAIg1sIglJDQAgACAOIAlrNgIEIAAgBCAJazYCACADIA0gDUEFdms7AQAMAgsgAyANQYAQIA1rQQV2ajsBACAAIAk2AgAgAEEBNgJoIABBCUELIAAoAmRBB0kbNgJkDAMLIAAgDiAEayIONgIEIA0gCSAJQQV2azsBACAPQagEaiENAkACQCADIARrIgNB////B00NACAQIQoMAQsgACADQQh0IgM2AgAgACAQQQFqIgo2AhAgACAOQQh0IAAoAgwgEGotAAByIg42AgQLAkACQCAOIANBC3YgDS8BACIEbCIJTw0AIAAgCTYCACANIARBgBAgBGtBBXZqOwEAIAAoAlghAwwBCyAAIA4gCWsiDjYCBCANIAQgBEEFdms7AQAgD0HABGohBAJAIAMgCWsiA0H///8HSw0AIAAgA0EIdCIDNgIAIAAgCkEBajYCECAAIA5BCHQgACgCDCAKai0AAHIiDjYCBAsCQAJAIA4gA0ELdiAELwEAIg1sIglPDQAgACAJNgIAIAQgDUGAECANa0EFdmo7AQAgACgCXCEDDAELIAAgDiAJazYCBCAAIAMgCWs2AgAgACgCYCEDIAAgACgCXDYCYCAEIA0gDUEFdms7AQALIAAgACgCWDYCXAsgACAAKAJUNgJYIAAgAzYCVAsgAEEIQQsgACgCZEEHSRs2AmQgACAHIAsQn4CAgAAMAQsgBCANQYAQIA1rQQV2ajsBACAAIAk2AgAgACAAKAJcNgJgIAAgACkCVDcCWCAAQQdBCiAAKAJkQQdJGzYCZCAAIAUgCxCfgICAACAAKAJoIgNBfmpBAyADQQZJGyEKIAAoAgAhA0EBIQ4DQCAAIApBB3RqIA5BAXQiDmpB2AdqIQ0CQAJAIANBgICACEkNACAAKAIEIQQMAQsgACADQQh0IgM2AgAgACAAKAIQIgRBAWo2AhAgACAAKAIEQQh0IAQgACgCDGotAAByIgQ2AgQLAkACQCAEIANBC3YgDS8BACIJbCIPSQ0AIAAgBCAPayIENgIEIAAgAyAPayIDNgIAIA0gCSAJQQV2azsBACAOQQFyIQ4MAQsgACAPNgIAIA0gCUGAECAJa0EFdmo7AQAgDyEDCyAOQcAASQ0ACwJAIA5BQGoiCUEDSw0AIAAgCTYCVAwBCyAAIA5BAXFBAnIiDTYCVCAJQQF2IQ8CQCAJQQ1LDQAgACANIA9Bf2oiDHQiCzYCVEEBIQ0gCCALQQF0akGEC2ohEEE/IA5rIRFBACEPA0AgECARIA1qQQF0aiEOAkACQCADQf///wdNDQAgAyEKDAELIAAgA0EIdCIKNgIAIAAgACgCECIDQQFqNgIQIAAgBEEIdCADIAAoAgxqLQAAciIENgIECwJAAkAgBCAKQQt2IA4vAQAiCWwiA0kNACAAIAQgA2siBDYCBCAAIAogA2siAzYCACAOIAkgCUEFdms7AQAgAEEBIA90IAtqIgs2AlQgDUEBdEEBciENDAELIAAgAzYCACAOIAlBgBAgCWtBBXZqOwEAIA1BAXQhDQsgDCAPQQFqIg9HDQAMAgsLIA9Be2ohDgNAAkAgA0H///8HSw0AIAAgA0EIdCIDNgIAIAAgACgCECIJQQFqNgIQIARBCHQgCSAAKAIMai0AAHIhBAsgACADQQF2IgM2AgAgACAEIANrIgRBH3UiCSANQQF0akEBaiINNgJUIAAgCSADcSAEaiIENgIEIA5Bf2oiDg0ACyAAIA1BBHQiCzYCVEEAIQ9BASEOA0AgACAOQQF0Ig5qQbwNaiENAkACQCADQf///wdNDQAgAyEKDAELIAAgA0EIdCIKNgIAIAAgACgCECIDQQFqNgIQIAAgBEEIdCADIAAoAgxqLQAAciIENgIECwJAAkAgBCAKQQt2IA0vAQAiCWwiA0kNACAAIAQgA2siBDYCBCAAIAogA2siAzYCACANIAkgCUEFdms7AQAgAEEBIA90IAtqIgs2AlQgDkEBciEODAELIAAgAzYCACANIAlBgBAgCWtBBXZqOwEACyAPQQFqIg9BBEcNAAsLAkAgASAGIAAoAlQQnoCAgAANAEEADwsgACgCICECCyACIAAoAihJDQALC0EBIQMCQCAAKAIAIgRB////B0sNACAAIARBCHQ2AgBBASEDIAAgACgCECIEQQFqNgIQIAAgACgCBEEIdCAEIAAoAgxqLQAAcjYCBAsgAwtwAQF/AkBBqN4BEICAgIAAIgJFDQAgAkE0aiABNgIAIAJBPGogADYCAAJAAkACQCAAQX9qDgIAAQILIAIgARCAgICAACIANgIYIAANASACEIKAgIAADAILIAJBADYCGCACQThqQQA2AgALIAIPC0EAC9IBAQJ/QQYhAgJAIAFBJ0sNACAAQTBqIAFBAXFBAnIgAUEBdkELanQiATYCAAJAAkAgAEE8aigCACIDRQ0AQQQhAiABIABBNGooAgBLDQIgAEEsaiABNgIAIANBAkcNACAAQThqIgMoAgAgAU8NACAAIAE2AjggACgCGBCCgICAACAAIAAoAjAQgICAgAAiATYCGCABDQBBAyECDAELQQAhAiAAQQA2AkAgAEHQAGpBAToAACAAQegAakEANgIAIABB5N0BaiEDCyADQQA2AgALIAILIwACQCAAQTxqKAIARQ0AIAAoAhgQgoCAgAALIAAQgoCAgAAL9QEBBH9BACEDAkAgACgCDCACTQ0AIAAoAhggAk0NACABIAEoAgAiBCAAKAIQIAAoAggiBWsiBiAEIAYgBEkbIgRrNgIAIAUgAkF/c2ohAQJAIAUgAksNACAAKAIUIAFqIQELIAAoAgAiAiABai0AACEGQQEhAyAAIAVBAWo2AgggAiAFaiAGOgAAAkAgBEF/aiICRQ0AA0AgACgCACIFQQAgAUEBaiIBIAEgACgCFEYbIgFqLQAAIQQgACAAKAIIIgZBAWo2AgggBSAGaiAEOgAAIAJBf2oiAg0ACwsgACgCDCAAKAIIIgFPDQAgACABNgIMCyADC8gEAQd/AkACQCAAKAIAIgNBgICACEkNACAAKAIEIQQMAQsgACADQQh0IgM2AgAgACAAKAIQIgVBAWo2AhAgACAAKAIEQQh0IAUgACgCDGotAAByIgQ2AgQLAkACQCAEIANBC3YgAS8BACIGbCIFTw0AIAEgBkGAECAGa0EFdmo7AQAgASACQQR0akEEaiEHQQghCEECIQkMAQsgACAEIAVrIgQ2AgQgASAGIAZBBXZrOwEAAkAgAyAFayIDQf///wdLDQAgACADQQh0IgM2AgAgACAAKAIQIgVBAWo2AhAgACAEQQh0IAUgACgCDGotAAByIgQ2AgQLAkAgBCADQQt2IAEvAQIiBmwiBU8NACABIAZBgBAgBmtBBXZqOwECIAEgAkEEdGpBhAJqIQdBCCEIQQohCQwBCyAAIAQgBWsiBDYCBCABIAYgBkEFdms7AQIgAUGEBGohByADIAVrIQVBgAIhCEESIQkLIABB6ABqIAk2AgBBASEBA0AgByABQQF0IgFqIQMCQAJAIAVB////B00NACAFIQIMAQsgACAFQQh0IgI2AgAgACAAKAIQIgVBAWo2AhAgACAEQQh0IAUgACgCDGotAAByIgQ2AgQLAkACQCAEIAJBC3YgAy8BACIGbCIFSQ0AIAAgBCAFayIENgIEIAAgAiAFayIFNgIAIAMgBiAGQQV2azsBACABQQFyIQEMAQsgACAFNgIAIAMgBkGAECAGa0EFdmo7AQALIAEgCEkNAAsgAEHoAGogASAIayAJajYCAAsLNQEAQYAICy4IAAAAEAAAABgAAAAgAAAAKAAAADAAAABAAAAAUAAAAIAAAAAAAQAA/Td6WFoA"},e=>{e.exports=A}],t={};function r(A){var i=t[A];if(void 0!==i)return i.exports;var n=t[A]={exports:{}};return e[A](n,n.exports,r),n.exports}r.d=(A,e)=>{for(var t in e)r.o(e,t)&&!r.o(A,t)&&Object.defineProperty(A,t,{enumerable:!0,get:e[t]})},r.o=(A,e)=>Object.prototype.hasOwnProperty.call(A,e),r.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})};var i={};return(()=>{r.r(i),r.d(i,{XzReadableStream:()=>n});var A=r(1);const e=globalThis.ReadableStream||r(2).ReadableStream;class t{constructor(A){this.exports=A.exports,this.memory=this.exports.memory,this.ptr=this.exports.create_context(),this._refresh(),this.bufSize=this.mem32[0],this.inStart=this.mem32[1]-this.ptr,this.inEnd=this.inStart+this.bufSize,this.outStart=this.mem32[4]-this.ptr}supplyInput(A){this.mem8.subarray(this.inStart,this.inEnd).set(A,0),this.exports.supply_input(this.ptr,A.byteLength),this._refresh()}getNextOutput(){const A=this.exports.get_next_output(this.ptr);if(this._refresh(),0!==A&&1!==A)throw new Error(`get_next_output failed with error code ${A}`);return{outChunk:this.mem8.slice(this.outStart,this.outStart+this.mem32[5]),finished:1===A}}needsMoreInput(){return this.mem32[2]===this.mem32[3]}outputBufferIsFull(){return this.mem32[5]===this.bufSize}resetOutputBuffer(){this.outPos=this.mem32[5]=0}dispose(){this.exports.destroy_context(this.ptr),this.exports=null}_refresh(){this.memory.buffer!==this.mem8?.buffer&&(this.mem8=new Uint8Array(this.memory.buffer,this.ptr),this.mem32=new Uint32Array(this.memory.buffer,this.ptr))}}class n extends e{static _moduleInstancePromise;static _moduleInstance;static async _getModuleInstance(){const e=A.replace("data:application/wasm;base64,",""),t=Uint8Array.from(atob(e),(A=>A.charCodeAt(0))).buffer,r=await WebAssembly.instantiate(t,{});n._moduleInstance=r.instance}constructor(A){let e,r=null;const i=A.getReader();super({async start(A){n._moduleInstance||await(n._moduleInstancePromise||(n._moduleInstancePromise=n._getModuleInstance())),e=new t(n._moduleInstance)},async pull(A){if(e.needsMoreInput()){if(null===r||0===r.byteLength){const{done:A,value:e}=await i.read();A||(r=e)}const A=Math.min(e.bufSize,r.byteLength);e.supplyInput(r.subarray(0,A)),r=r.subarray(A)}const t=e.getNextOutput();A.enqueue(t.outChunk),e.resetOutputBuffer(),t.finished&&(e.dispose(),A.close())},cancel:()=>(e.dispose(),i.cancel())})}}})(),i})(),A.exports=r(t(70772))}}]);